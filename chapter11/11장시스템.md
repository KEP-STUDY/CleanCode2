# 11장 시스템

Created: Jan 2, 2021 1:42 PM

## 도시를 세운다면?

- 혼자서 관리 불가
- 각 분야를 담당하는 팀
- 적절한 추상화와 모듈화
    - 개인이 관리하는 구성요소는 효율적으로 돌아감

## 시스템 제작과 시스템 사용을 분리해라

- 제작, 시스템은 다르다
- 소프트웨어 시스템은 준비 과정과 준비과정 이후에 이어지는 런타임 로직을 분리해야한다.
- 관심사 분리
    - 불행히 대다수 애플리케이션은 시작단계에서 분리하지 않음..

```kotlin
public Service getService(){
	if(service == null){
		service = new ServiceImpl();
		//런타임 로직
	}
	return service;
}

```

- 초기화 지연 / 계산 지연 기법
    - 장점 - 필요하기전까지 객체가 생성이 안됨, null포인터 반환 X
    - 단점 - 함수가 생성자 인수에 명시적으로 의존함
        - 아무리 안써도 의존성을 해결하지 않으면 컴파일이 안 된다. (컴파일언어 특징!)
        - 테스트
            - 테스트 전용 객체를 service필드에 할당 해야함
            - 모든 경로도 테스트 해야 함
            - 결론 SRP(단일 책임 원칙)을 깬다
        - 모든 상황에서의 적합한 객체인지 모름
- 체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대로 안된다!

### 시스템 생성 / 사용 분리 방법

1. Main 분리

![11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%205711d5e84dda46fc8b5fa4eb0321036b/Untitled.png](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%205711d5e84dda46fc8b5fa4eb0321036b/Untitled.png)

- 생성 관련 코드는 main이나 main이 호출되는 모듈로 옮긴다.
- 나머지 시스템은 모든 객체가 생성이 되었고 의존성이 연결되었다고 가정

2. 팩토리 

- 객체가 생성되는 시점을 애플리케이션이 결정해야할때 사용
- 추상 팩토리 패턴 사용

![11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%205711d5e84dda46fc8b5fa4eb0321036b/Untitled%201.png](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%205711d5e84dda46fc8b5fa4eb0321036b/Untitled%201.png)

- 의존성이 main → orderProcessing으로 이동
- OrderProcessing 는 LineItem이 어떻게 생성되는지 모름
- 하지만 OrderProcessing은 LineItem생성하는데 통제..

### 의존성 주입 (Dependency Injection)

- 사용자 제작을 분리하는 매커니즘
- IoC기법을 의존성 관리에 적용한 매커니즘
    - 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 넘김
- 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않음!
- 초기설정은 시스템 전체에서 필요하므로 책임질 매커니즘으로 main루틴, 특수 컨테이너 사용
    - 스프링은 DI컨테이너
- 진정한 의존성 주입
    - 클래스가 의존성을 해결하려고 하지 않음
    - setter, 생성자 인수를 제공
    - DI컨테이너는 필요한 객체의 인스턴스를 만든 후 생성자인수나 설정자 메서드를 사용해 의존성을 설정
- DI를 사용하더라도 초기화 지연의 장점을 얻을 수 있다
    - DI컨테이너는 필요할 때까지 객체 생성 X
    - 계산 지연, 비슷한 최적화에 쓸 수 있도록 팩토리호출, 프록시 방법 제공

### 확장

- 조그만한 마을에 6차선 도로 깐다
    - 미친짓ㅋㅋㅋㅋ
- 시스템도 사용자 스토리에 맞춰 시스템을 구현해야 함
    - 새로운 스토리가 생기면 그때 확장하면 됨
- 소프트웨어 시스템은 관심사를 적절히 분리해 관리하면 스프트웨어 아키텍처는 점진적으로 발전 할 수 있다.

### 횡단 관심사 (cross-cutting concerns)

- 영속성 관심사
    - 자연스러운 객체의 경계를 넘다듬
    - 모든 객체가 전반적인 동일한 방식을 이용하게 만들어야함
    - 현실적으로 영속성 방식을 구현한 코드가 온갖 객체로 흩어짐...
- AOP
    - 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론
    - 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성있게 바꿔야한다
- 횡단 관심사
    - 다른 관심사에 영향을 미치는 프로그램의 애스펙트이다.
    - 이 관심사들은 디자인과 구현 면에서 시스템의 나머지 부분으로부터 깨끗이 분해되지 못하는 경우가 있을 수 있으며 분산(코드 중복)되거나 얽히는(시스템 간의 상당한 의존성 존재) 일이 일어날 수 있다.
    - example
        - 의무기록을 관리하기 위한 애플리케이션을 작성한다고 했을 때 이러한 기록의 색인화는 핵심 관심사인 한편 변경 이력을 기록 데이터베이스나 사용자 데이터베이스에 로깅하는 일이라든지, 인증 시스템과 같은 것은 횡단 관심사
    - Filter, interceptor 도 횡단 관심사에서 나왔지 않았을까..???

### 프록시

- 어떻게 사용하는가?
    - 첨부된 코드 참조 (자바)

### AOP 프레임워크

- 여러 자바 프레임워크는 내부적으로 프록시를 많이 이용한다
- 프로그래머는 설정 파일이나 API를 이용하여 필수적인 애플리케이션 기반 구조를 구현한다.
- 횡단 관심사도 포함
- 프레임워크는 사용자가 모르게 프록시나, 바이트 코드 라이브러리를 사용해 구현
- 스프링 AOP

    ![11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%205711d5e84dda46fc8b5fa4eb0321036b/Untitled%202.png](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%205711d5e84dda46fc8b5fa4eb0321036b/Untitled%202.png)

### AspectJ

- 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장
- 관점 분리하는 강력하고 풍부한 도구 → 새 문법을 배워야하는 단점
- AspectJ 애너테이션 폼
    - 새로운 도구와 새로운 언어라는 부담을 완화

```xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjrt</artifactId>
    <version>1.8.9</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.8.9</version>
</dependency>
```

- aj라는 확장자 사용
- 직접 써보니 지금 쓰는 곳이 있을까??라는 생각이 듬...

[Intro to AspectJ | Baeldung](https://www.baeldung.com/aspectj)

### 참고 자료 Spring AOP vs AspectJ

[Spring AOP와 AspectJ 비교하기](https://logical-code.tistory.com/118)

## Spring AOP

(다른 프레임워크에도 있을까?) → play framework도 가능하다곤 함..

### 주요개념

- Aspect : 위에서 설명한 흩어진 관심사를 모듈화 한 것. 주로 부가기능을 모듈화함.
- Target : Aspect를 적용하는 곳 (클래스, 메서드 .. )
- Advice : 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체
- JointPoint : Advice가 적용될 위치, 끼어들 수 있는 지점. 메서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올 때 등 다양한 시점에 적용가능
- PointCut : JointPoint의 상세한 스펙을 정의한 것. 'A란 메서드의 진입 시점에 호출할 것'과 같이 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있음

### 문법

- @Before (이전) : 어드바이스 타겟 메소드가 호출되기 전에 어드바이스 기능을 수행
- @After (이후) : 타겟 메소드의 결과에 관계없이(즉 성공, 예외 관계없이) 타겟 메소드가 완료 되면 어드바이스 기능을 수행
- @AfterReturning (정상적 반환 이후)타겟 메소드가 성공적으로 결과값을 반환 후에 어드바이스 기능을 수행
- @AfterThrowing (예외 발생 이후) : 타겟 메소드가 수행 중 예외를 던지게 되면 어드바이스 기능을 수행
- @Around (메소드 실행 전후) : 어드바이스가 타겟 메소드를 감싸서 타겟 메소드 호출전과 후에 어드바이스 기능을 수행

## 테스트 주도 시스템 아키텍처 구축

- 관심사를 분리하는 방식은 위력이 막강
- **테스트 주도 아키텍처** 구축 가능
- BDUF 추구 X
    - 프로그램의 구현이 사작되기전에 프로그램 디자인이 완료되는 소프트웨어 개발 접근 방식
    - 엄청 어려울것 같은데..??
    - 애자일 기법과 많이 분류됨..

### 요약

- 최선의 시스템 구조는 POJO 객체로 구현되는 모듈화된 관심사영역으로 구성된다.
- 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다.
- 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할수 있다

### 의사 결정을 최적화해라

- 관심사를 모듈로 분리한 POJO시스템은 기민함을 제공한다
- 기민함 덕택에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기 쉬워진다
- 결정의 복잡성을 줄어든다

### 명백한 가치가 있을때 표준을 현명하게 사용해라

- 표준을 사용하면 컴포넌트 재사용 쉬움
- 적절한 경험을 가진사람을 구하기 쉬움, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉬움
- 다만, 표준이 오래걸려서 업계가 기다리지 못할 수도 있음...

- EJB2 → 표준이라는 이유만으로 많은 팀이 사용

### 시스템은 도메인 특화 언어가 필요

- DSL
    - 간단한 스크립트 언어나 표준 언어로 구현한 API
    - 의사소통 간극을 줄어든다
    - 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다
    - 

[도메인 특화 언어(DSL)에 관한 설명 | JetBrains MPS](https://www.jetbrains.com/ko-kr/mps/concepts/domain-specific-languages/)

### 결론

- 시스템은 깨끗해야한다.
- POJO하세요